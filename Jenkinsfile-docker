pipeline {
    agent {
        docker {
            image 'hashicorp/terraform:latest'
            args '-u root:root -v /var/run/docker.sock:/var/run/docker.sock'
        }
    }

    // Enable SCM polling - check for changes every 5 minutes
    triggers {
        pollSCM('H/5 * * * *')
    }

    parameters {
        booleanParam(name: 'autoApprove', defaultValue: true, description: 'Automatically run apply after generating plan?')
        choice(name: 'action', choices: ['apply', 'destroy'], description: 'Select the action to perform')
        string(name: 'keyPairName', defaultValue: 'redis-infra-key', description: 'AWS Key Pair name to use')
        booleanParam(name: 'recreateKeyPair', defaultValue: false, description: 'Force recreate key pair if it exists?')
        booleanParam(name: 'skipAnsible', defaultValue: false, description: 'Skip Ansible configuration step?')
    }

    environment {
        AWS_DEFAULT_REGION = 'ap-south-1'
        KEY_PAIR_NAME = "${params.keyPairName}"
        TF_IN_AUTOMATION = 'true'
        TF_INPUT = 'false'
    }

    stages {
        stage('Setup Tools') {
            steps {
                sh '''
                    echo "=== Installing Required Tools ==="
                    apk add --no-cache curl python3 py3-pip git openssh-client
                    
                    # Install AWS CLI
                    pip3 install awscli
                    
                    # Install Ansible
                    pip3 install ansible boto3 botocore
                    
                    # Verify installations
                    aws --version
                    terraform --version
                    ansible --version
                '''
            }
        }

        stage('Clone Repository') {
            steps {
                echo "=== Cloning Repository ==="
                checkout scm
                
                // Display commit information
                script {
                    def commitId = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
                    def commitMsg = sh(returnStdout: true, script: 'git log -1 --pretty=%B').trim()
                    def commitAuthor = sh(returnStdout: true, script: 'git log -1 --pretty=%an').trim()
                    
                    echo "Commit ID: ${commitId}"
                    echo "Commit Message: ${commitMsg}"
                    echo "Commit Author: ${commitAuthor}"
                }
            }
        }

        // ... rest of your stages remain the same
        stage('Pre-flight Checks') {
            steps {
                echo "=== Pre-flight Checks ==="
                withCredentials([
                    string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
                    string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY')
                ]) {
                    sh '''
                        echo "Checking AWS credentials..."
                        aws sts get-caller-identity
                        
                        echo "Checking AWS service limits..."
                        aws ec2 describe-account-attributes --attribute-names supported-platforms --region $AWS_DEFAULT_REGION
                        
                        echo "Checking existing resources..."
                        aws ec2 describe-vpcs --region $AWS_DEFAULT_REGION --query 'Vpcs[?Tags[?Key==`Name` && Value==`redis-VPC`]]' --output table || true
                    '''
                }
            }
        }

        // Include all other stages from your original Jenkinsfile...
    }

    post {
        always {
            script {
                // Archive key file if created (for download)
                if (fileExists("${params.keyPairName}.pem")) {
                    archiveArtifacts artifacts: "${params.keyPairName}.pem", allowEmptyArchive: true
                }
                
                // Archive Terraform state files
                if (fileExists("terraform/terraform.tfstate")) {
                    archiveArtifacts artifacts: 'terraform/terraform.tfstate*', allowEmptyArchive: true
                }
            }
            
            // Clean workspace but keep important files
            sh '''
                # Keep important files but clean temporary ones
                find . -name "*.log" -delete || true
                find . -name ".terraform" -type d -exec rm -rf {} + || true
            '''
        }
        
        failure {
            echo '❌ Pipeline failed!'
            script {
                sh '''
                    echo "=== Failure Diagnostics ==="
                    echo "Checking AWS resources that might need cleanup..."
                    
                    # Check for any resources that might have been partially created
                    aws ec2 describe-instances --region $AWS_DEFAULT_REGION --filters "Name=tag:Name,Values=redis-*" --query 'Reservations[].Instances[].{Name:Tags[?Key==`Name`].Value|[0],State:State.Name,InstanceId:InstanceId}' --output table || true
                    
                    echo "Check the logs above for specific error details."
                    echo "You may need to run cleanup manually if resources were partially created."
                '''
            }
        }
        
        success {
            echo '✅ Pipeline completed successfully!'
            echo "Redis infrastructure deployed with key pair: ${params.keyPairName}"
            echo "Check the 'Generate Connection Guide' stage output for connection details."
            echo "Download the connection-guide.txt and ${params.keyPairName}.pem files from Jenkins artifacts."
        }
    }
}
